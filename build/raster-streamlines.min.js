// raster-streamlines Version 0.1.0. Copyright 2020 Roger Veciana i Rovira.
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e(t.rastertools=t.rastertools||{})}(this,function(t){"use strict";function e(t,e){if(t.length<=1||e.length<=1||t[0].length<=1||e[0].length<=1)throw new Error("Raster is too small");if(t.length!==e.length||t[0].length!==e[0].length)throw new Error("Raster components are not the same shape");this.uData=t,this.vData=e,this.xSize=this.uData[0].length,this.ySize=this.uData.length,this.usedPixels=[];for(var i=0;i<this.ySize;i++){for(var s=[],r=0;r<this.xSize;r++)s.push(!1);this.usedPixels.push(s)}}function i(t,e,i){return t<=e?e:t>=i?i:t}var s=function(t,i,s,r,o){r=r||1;var a={type:"FeatureCollection",features:[]},h=0,n=new e(t,i);if(s){if(6!==s.length)throw new Error("Bad geotransform")}else s=[0,1,0,0,0,1];const u=Math.round(n.ySize/(60*r))||1;for(var f=n.xSize*n.ySize,l=0;l<f;l++){var p=327685*l%f,x=Math.trunc(p/n.ySize),y=p%n.ySize;if(n.isPixelFree(x,y,u)){var S=n.getLine(x,y,o);S&&(a.features.push({type:"Feature",geometry:{type:"LineString",coordinates:n.applyGeoTransform(S,s)},properties:{num_line:h}}),h++)}}return a};e.prototype.isPixelFree=function(t,e,i){if(t<0||t>=this.xSize||e<0||e>=this.ySize)return!1;const s=Math.max(t-i,0),r=Math.min(t+i,this.xSize-1),o=Math.max(e-i,0),a=Math.min(e+i,this.ySize-1);for(var h=s;h<=r;h++)for(var n=o;n<=a;n++)if(this.usedPixels[n][h])return!1;return!0},e.prototype.getLine=function(t,e,i){var s,r=!1,o=t,a=e,h=[[o,a]];for(i=i?1:-1;o>=0&&o<this.xSize&&a>=0&&a<this.ySize;){if(s=this.getValueAtPoint(o,a),o+=s.u,a+=i*s.v,0===s.u&&0===s.v){this.usedPixels[e][t]=!0;break}if(o<0||a<0||o>=this.xSize||a>=this.ySize||this.usedPixels[Math.floor(a)][Math.floor(o)])break;h.push([o,a]),r=!0,this.usedPixels[Math.floor(a)][Math.floor(o)]=!0}for(o=t,a=e;o>=0&&o<this.xSize&&a>=0&&a<this.ySize;){if(s=this.getValueAtPoint(o,a),o-=s.u,a-=i*s.v,0===s.u&&0===s.v){this.usedPixels[e][t]=!0;break}if(o<0||a<0||o>=this.xSize||a>=this.ySize||this.usedPixels[Math.floor(a)][Math.floor(o)])break;h.unshift([o,a]),r=!0,this.usedPixels[Math.floor(a)][Math.floor(o)]=!0}return!!r&&(this.usedPixels[e][t]=!0,h)},e.prototype.applyGeoTransform=function(t,e){for(var i=[],s=0;s<t.length;s++)i.push([e[0]+e[1]*t[s][0]+e[2]*t[s][1],e[3]+e[4]*t[s][0]+e[5]*t[s][1]]);return i},e.prototype.getValueAtPoint=function(t,e){const s=i(Math.floor(t),0,this.xSize-2),r=s+1,o=i(Math.floor(e),0,this.ySize-2),a=o+1,h=t-s,n=1-h,u=e-o,f=1-u,l=f*n,p=u*n,x=f*h,y=u*h,S=this.uData[o][s]*l+this.uData[o][r]*p+this.uData[a][s]*x+this.uData[a][r]*y,z=this.vData[o][s]*l+this.vData[o][r]*p+this.vData[a][s]*x+this.vData[a][r]*y,d=Math.sqrt(S*S+z*z)||1;return{u:S/d,v:z/d}},t.streamlines=s,Object.defineProperty(t,"__esModule",{value:!0})});